<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
</html>
<script>
  // 一.数组的方法(动态方法、实例方法、原型方法)
  // 通过new关键字调用类(构造函数)，产生实例对象，给实例对象使用的方法就是动态方法，实例方法，原型方法。
  // 1.第一组方法：栈方法(后进先出)

  // 1.1.push() 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度，改变原数组
  // var arr = ["zhangsan"];
  // console.log(arr.push("lisi", "wangwu")); //逐个添加到数组末尾  返回修改后数组的长度3,
  // console.log(arr); // ['zhangsan', 'lisi', 'wangwu']

  // 1.2.pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项，改变原数组
  // var arr = ["zhangsan", "lisi", "wangwu"];
  // console.log(arr.pop()); //wangwu
  // console.log(arr.pop()); //lisi
  // console.log(arr.pop()); //zhangsan
  // console.log(arr); //[]

  // 案例：清空一个数组。
  // var arr = ["zhangsan", "lisi", "wangwu", "zhaoliu"];
  // 1.利用length属性。
  // arr.length = 0;
  // console.log(arr);
  // 2.利用变量的特点。
  // arr = [];
  // console.log(arr);
  // 3.利用pop方法 + 循环遍历
  // for (var i = 0, len = arr.length; i < len; i++) {
  //   arr.pop();
  // }
  // console.log(arr);

  // 第二组方法：队列方法(先进先出)
  // 2.1.unshift()可以接收任意数量的参数，把它们逐个添加到数组前面，并返回修改后数组的长度，改变原数组
  // var arr = [100, 200];
  // console.log(arr.unshift(300, 400, 500, 600)); //6
  // console.log(arr);
  // 2.2.shift() 从数组前面移除一项，减少数组的length值，然后返回移除的项，改变原数组
  // var arr = [100, 200, 300];
  // console.log(arr.shift()); //100
  // console.log(arr); //[200, 300]

  // 第三组方法：重排序方法
  // 3.1. reverse() 方法会反转数组项的顺序，改变原数组
  // var arr = [1, 2, 3, 4, 5];
  // console.log(arr.reverse()); //[5, 4, 3, 2, 1]
  // console.log(arr); //[5, 4, 3, 2, 1]

  // 3.2. sort() 方法按字母升序排列数组项，如果按其他方式而非字母表顺序进行数组排列，必须给sort方法传递一个比较函数做参数，改变原数组

  // 排序字符串，通过unicode编码进行升序排序
  // a-z:97-122
  // A-Z:65-90
  // 0-9:48-57
  // var arr = ["lisi", "wangwu", "zhangsan", "chener"];
  // console.log(arr.sort()); //['chener', 'lisi', 'wangwu', 'zhangsan']

  // 如果利用sort方法排序数字，作者也准备策略。
  // 策略：准备了比较函数，利用作者准备的函数进行排序数字。将比较函数当中sort方法的参数。
  // function hehe(value1, value2) {
  //   //value1和value2就是数组项
  //   return value1 - value2;
  // }
  // let arr1 = [5, 6, 7, 12, 13, 45];
  // console.log(
  //   arr1.sort((a, b) => {
  //     return b - a;
  //   })
  // );
  // var arr = [13, 5, 45, 6, 12, 7];
  // // console.log(arr.sort(hehe)); //[5, 6, 7, 12, 13, 45]  按照字符串
  // console.log(
  //   arr.sort(function (a, b) {
  //     //按照升序
  //     return a - b;
  //   })
  // );

  // console.log(
  //   arr.sort(function (x, y) {
  //     //降序
  //     return y - x;
  //   })
  // );

  // 自己封装函数实现排序。
  // 冒泡排序
  // 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  // 对每一对相邻元素做同样的工作,从开始第一对到结尾的最后一对,在这一点，最后的元素应该会是最大的数。
  // 针对所有的元素重复以上的步骤，除了最后一个。
  // 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

  // 交互位置 - 利用中间变量交互
  // var a = 8;
  // var b = 10;
  // var temp = a; //temp = 8
  // a = b; //a = 10;
  // b = temp; //b = 8

  // console.log(a); //10
  // console.log(b); //8

  // var arr = [13, 5, 45, 6, 12, 7];
  // //数组项比较的轮数(第几轮的意思),-1因为6个数字比较5轮
  // for (var i = 0; i < arr.length - 1; i++) {
  //   //两两比较,-1:6个数字只需要两两比较5次。-i:每一轮都会有一个数字排行，剩余的数字就少了。
  //   for (var j = 0; j < arr.length - i - 1; j++) {
  //     if (arr[j] > arr[j + 1]) {
  //       var temp = arr[j];
  //       arr[j] = arr[j + 1];
  //       arr[j + 1] = temp;
  //     }
  //   }
  // }
  // console.log(arr); //[5, 6, 7, 12, 13, 45]
  let arr = [13, 5, 45, 6, 12, 7];
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  console.log(arr);
  function bubbleSort(arr) {
    if (Array.isArray(arr)) {
      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            let temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
        }
      }
    }
    return arr;
  }
  console.log(bubbleSort([45, 96, 23, 1, 7, 6]));
  // 函数封装实现冒泡排序
  // function bubbleSort(arr) {
  //   // 判断arr是否是函数
  //   if (Array.isArray(arr)) {
  //     //是数组
  //     for (var i = 0; i < arr.length - 1; i++) {
  //       for (var j = 0; j < arr.length - i - 1; j++) {
  //         if (arr[j] > arr[j + 1]) {
  //           var temp = arr[j];
  //           arr[j] = arr[j + 1];
  //           arr[j + 1] = temp;
  //         }
  //       }
  //     }
  //     return arr;
  //   } else {
  //     alert("请输入数组");
  //   }
  // }

  // console.log(bubbleSort([5, 6, 7, 12, 13, 45]));
  // console.log(bubbleSort(123));
</script>
