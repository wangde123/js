<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    // 一.Promise的概述
    // Promise 承诺的意义。
    // Promise Es6新增的可以解决回调地狱的问题，是一个构造函数。
    // Promise 异步编程的一种解决方案，比传统的解决方案（回调函数）更合理和更强大。
    // Promise 对象代表一个异步操作，有三种状态：pending进行中、fulfilled(resolve)成功、rejected失败。

    // 二.Promise对象有以下两个特点。
    // 1.对象的状态不受外界影响
    // 2.一旦状态设定，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected,只要这两种情况发生，状态就凝固了.
    // 解读：Promise的状态可以自由设定，但是一旦设定，不可改变，而且只有两种可能，要么进行中到成功，要么进行中到失败。

    // 三.promise原型下面三个常用的方法：这里的方法就是前面学习的一些对象产生的实例方法(数组和字符串等对象下面的方法都是原型方法，因为都是绑定在原型下面的)。

    // 创建promise对象, 函数做参数(回调函数), 而这个做参数的函数又有两个参数， 表示成功的回调和失败的回调。这两个参数就表示两个状态，自由设定状态。
    // let p1 = new Promise((resolve, reject) => { //resolve：成功的回调  reject：失败的回调
    //     resolve('success'); //成功  状态一旦设定，不可改变，除非删除这个状态。
    //     reject('fail'); //失败
    // });
    // 1.Promise.prototype.then  
    // 当promise的状态设定为resolve，就会执行then方法，并且resolve的参数会传递给then里面的回调函数。
    // p1.then((str) => {
    //     console.log(str); //success
    // });

    // 2.Promise.prototype.catch  
    // 当promise的状态设定为reject，就会执行catch方法，并且reject的参数会传递给catch里面的回调函数。
    // p1.catch((e) => {
    //     console.log(e);//fail
    // });

    // 3.采用链式写法实现成功和失败状态操作
    // p1.then((d) => {
    //     console.log(d);
    // }).catch((e) => {
    //     console.log(e);
    // });

    // 4.promise对象下面的then和catch方法本身也会返回promise实例对象，否则就无法链式操作。
    // resolve状态返回的值只给第一个then。
    p1.then((d) => {
            console.log(d); //输出success，p1的状态执行它
            return new Promise((resolve, reject) => {
                resolve('success123');
            });
        })
        .then((d) => { //success123,这里的参数值是上面的then里面的状态传下来值。
            console.log(d);
            return new Promise((resolve, reject) => {
                resolve('success123456');
            });
        })
        .then((d) => {
            console.log(d); //success123456  这里的d必须依靠上面的then里面的状态传下来。
        });

    // 5.Promise.prototype.finally
    // finally方法用于指定不管Promise对象最后状态如何,都会执行的操作,该方法是ES2018(ES9)引入标准的。
    // finally可以省略。
    // let p1 = new Promise((resolve, reject) => { //resolve：成功的回调  reject：失败的回调
    //     reject('error');
    // });
    // p1.then((d) => {
    //     console.log(d);
    // }).catch((e) => {
    //     console.log(e);
    // }).finally(() => {
    //     console.log('finally一定会执行的');
    // });
</script>