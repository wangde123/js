<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body></body>
</html>
<script>
  //构造函数
  // 1.对象是javascript的数据类型,对象是一种复合值,它将很多值聚合在一起,可通过名字访问这些值,对象也看做是属性的无序集合,每个属性都是一个键/值对。
  // 注意：对象是由属性和方法构成的。当属性的值是函数的时候，才会变成对象下面的方法，在不确定值的情况下当作属性的无序集合。
  // var obj = new Object();//obj:自定义对象    Object:系统约定的类名
  // obj.name = 'zhangsan',//添加自定义属性，'zhangsan'自定义属性值，obj.name自定义属性
  //     obj.age = 18,
  //     obj.show = function () {
  //         ////添加自定义属性(方法)
  //         return '我是obj对象的返回值'
  //     }
  // console.log(obj.show)//输出属性值
  // console.log(obj.show())//调用方法的值

  // 2.2.字面量创建对象(注意格式：键值对的格式，key:value格式)
  // var obj = {
  //     name: 'zhangsan',
  //     age: 18,
  //     show: function () {
  //         return '我是obj对象的返回值'
  //     }
  // }

  // console.log(obj.show)//输出属性值
  // console.log(obj.age)//输出属性值
  // console.log(obj.show())//调用方法的值

  // 作业
  // 使用字面量形式创建一个对象，该对象包含姓名，学号、年龄、性别、所学专业，和一个自我介绍的方法，用来输出该对象的所有信息.
  // var obj = {
  //     name: 'zhangsan',
  //     id: "00123",
  //     age: 18,
  //     nv: '男',
  //     pro: 'web开发',
  //     sec: function () {
  //         return '我的名字叫' + obj.name + ',我的学号是' + obj.id + ',我今年' + obj.age + '岁，我是' + obj.nv + '我的专业是' + obj.pro
  //     }
  // }
  // document.write(obj.sec())//我的名字叫zhangsan,我的学号是00123,我今年18岁，我是男我的专业是web开发

  // 一.自定义对象的特点 - 非常重要
  // 1.对象的属性名一定是字符串格式，引号可有可无.
  //   console.log(obj.name); //zhangsan
  // console.log(obj.id); //00123

  // 2.对象的属性不存在，不会报错，输出undefined,对象的属性值可以被覆盖。
  // 注意：方法不存在会报错，方法是要调用，涉及到函数。
  // console.log(obj.hehe)//underfined
  // //    console.log(obj.s())//Uncaught TypeError: obj.s is not a function
  // obj.pro = 'ssdf'
  // console.log(obj.pro)//覆盖上面

  // 3.获取设置对象的属性值可以通过点符号和中括号。
  // 区别是：访问属性约定点符号后面跟的一定是字符串(必须忽略引号)，中括号里面可以是字符串(必须添加引号)和变量获取其他语法。
  // console.log(obj['name'])
  // console.log(obj.name)

  //     // 例子：使用变量当对象的属性名 - 非常重要
  //     var a='name';
  //     var obj={
  //         a:'zhangsan',
  //         [a]:'lisi'
  //     }
  // console.log(obj.a)//zhangsan字符串
  // console.log(obj[a])//lisi变量
  // console.log(obj.name);//lisi变量
  // console.log(obj['a']);//zhangsan
  // obj.a = 1
  // obj.1 = 2; //报错，点后面跟字符串，不是数字。
  // 总结：当处理对象属性出现变量最好采用中括号，否则采用点符号。

  //栈和堆
  //栈：存放引用类型的地址和基本的类型的值和地址
  //堆：存放引用类型的值
  //对象类型(引用类型)：存在地址和值两部分，比较的对象的时候其实比较的是地址。
  // console.log(true===true)//true
  // console.log('zhangsan'==='zhangsan')//true
  // console.log([]===[])//false
  // console.log({}==={})//false
  // console.log(function(){}===function(){})//false
  //基本类型遵循值传递，彼此传递的都是值。
  // var a = 10;
  //     var b = a; //值传递，将a的值复制一份传给b，所有b=10,而且a,b是两个变量
  //     b++;
  //     console.log(a);//10
  //     console.log(b)//11
  //引用类型遵循引用传递，彼此传递的是地址。
  // var arr=[1,2,3]
  // var arr1=arr//引用传递。传递的是地址，arr和arr1会指向同一地址
  // arr1.push(4)
  // console.log(arr)
  // console.log(arr1)
  // 一般采用逐个赋值的方式
  // var arr=[1,2,3]
  // var arr1=[]
  // for(var i=0;i<arr.length;i++){
  //     arr1[i]=arr[i]
  // }
  // arr1.push(4)
  // console.log(arr)
  // console.log(arr1)
  //总结：如果对象间用赋值，其实赋值的是地址，最终指向同一内存，出现统一改变的情况，目前用逐一赋值的方法

  //位置方法：indexof() lastIndexOf()返回要查找的项在数组中的索引位置，没找到的情况下返回-1。
  // 两个参数：要查找的数组项 和 表示查找起点位置的索引（可选的）
  //indexOf() 方法从数组的开头开始向后查找,查找参数在数组中的索引位置，没找到的情况下返回-1。
  //  var arr = ['zhangsan', 'lisi', 'wangwu', 'zhangsan', 'lisi', 'wangwu'];
  //  console.log(arr.indexOf('zhangsan'));
  //  console.log(arr.indexOf('lisi'));
  //  console.log(arr.indexOf('zhaoliu'));//找不到的情况下返回-1
  //  console.log(arr.indexOf('zhangsan',1))//从索引1位置向后找'zhangsan'

  // 案例：数组去重
  // 思路：查看当前的数组项的值是否存在新数组，不存在追加进新数组
  // var arr = [1, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5]
  // var newarr = []//存放新数组
  // for (var i = 0; i < arr.length; i++) {
  //     if (newarr.indexOf(arr[i]) === -1){
  //         newarr.push(arr[i])
  //     }
  // }
  // console.log(newarr)//1,2,3,4,5

  //lastIndexOf() 方法则从数组的末尾开始向前查找。(注意：索引一定是从前往后数)
  // var arr = ['zhangsan', 'lisi', 'wangwu', 'zhangsan', 'lisi', 'wangwu'];

  // console.log(arr.lastIndexOf('zhangsan'));//3
  // console.log(arr.lastIndexOf('lisi'));//4
  // console.log(arr.lastIndexOf('wangwu'));//5
  // console.log(arr.lastIndexOf('wangwu',-2));//2

  // 一.迭代方法：迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果.
  // 自带遍历(循环)
  // 每个方法带有两个参数：
  // 第一个参数：要在每一项上运行的函数(函数当参数，回调函数),此函数会接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。
  // 第二个参数： 运行该函数的作用域对象即this 的值[可选的] - 直接忽略
  //  every()  对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则整个方法返回 true 。
  // var arr = [1, 2, 3, 4, 5];
  // var asc =arr.every(function(v,i,array){
  //     console.log(v)// 1 数组项的值，因为此方法的特性，仅输出第一个
  //     console.log(i);//0 数组项对应的索引值，因为此方法的特性，仅输出第一个
  //     console.log(array)//数组对象本身
  //     return v>3
  // })
  // console.log(asc)
  // 此方法适合数组项都满足某一条件时的应用
  // 案例：证明一个数组是数字组成的数组。
  //     var arr = [1, 2, 3, 4, 5, 'abc', 6];
  //   var asc=  arr.every(function(v,i,every){
  // return typeof v==='number' //判断数组的每一项值的类型是否是number类型，如果有任意一项不满足，整个every输出false
  //     })
  // console.log(asc)//false

  //  some()  对数组中的每一项运行给定函数，如果该函数对任意一项返回 true ，则返回 true 。
  // var arr = [1, 2, 3, 4, 5];
  // var asc=arr.some(function(v,i,array){
  // // console.log(v)//返回所有数组项的值。
  // // console.log(i);//返回所有数组项对应的索引值。
  // // console.log(array);////数组对象本身
  // return v>3
  // }
  // )
  // console.log(asc)
  //filter()对数组中的每一项运行给定函数，返回该函数结果为 true 的项组成的数组。
  // filter:过滤，筛选
  // var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  // var sac=arr.filter(function(v,i,array){
  // // // console.log(v);
  // // // console.log(i);
  // // // console.log(array);
  // // return v%2===0

  // })
  // console.log(sac)
  // 案例：数组去重
  //     var arr = [35, 35, 35, 22, 22, 22, 22, 66, 66, 66, 66, 66];
  //    var sac= arr.filter(function(v,i,array){
  //        console.log(arr.indexOf(v));//获取第一次出现的值的索引位置 0,0,0,3,3,3,3,7,7,7,7,7
  //        console.log(i);//每一个数组项对应的索引                    0,1,2,3,4,5,6,7,8,9,10,11
  //        return arr.indexOf(v)===i//只有当这两个值相等表示数组项是第一次出现。indexOf只找第一次出现的值的索引位置。
  //     })
  //     console.log(sac);

  // 筛选数组
  //     var arr = [12, 'hello', 'hi', 333, 'abc', 444];
  //    var asc= arr.filter(function(v,i,array){
  // // return typeof v==='number'
  // return typeof v==='string'
  //     })
  //     console.log(asc);

  //  map()  对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组，返回就是数组，不考虑true或者false；
  // map：映射，一一对应,就是数组的每一项做完都会输出。比如10项的数组输出还是10项。
  //  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  //  var asc=arr.map(function(v,i,a){
  // return v*100
  //  })

  // console.log(asc);
  //  forEach()  对数组中的每一项运行给定函数。这个方法没有返回值，取代for循环。
  //  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  //  arr.forEach(function(v,i,a){
  // console.log(v);
  // // console.log(a);
  // // console.log(i);
  //  })
  // for(var i=0;i<arr.length;i++){
  //     console.log(arr[i])
  // }

  // 归并方法
  // 即每一次迭代得到的结果会作为下一次迭代的初始值，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。
  // 两个参数：每一项上调用的函数 和（可选的）作为归并的初始值(迭代的初始值)
  //     var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  //     // 1.reduce() 方法从数组的第一项开始，逐个遍历到最后。从第一项开始迭代所有值的和。
  //     // 一个参数的情况：
  //     // 调用的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。
  // var sac=arr.reduce(function(q,h,i,a){
  // return q+h//q:第一次是数组第一项，后面就是算法迭代的结果。
  // })
  // console.log(sac)
  // 两个参数的情况
  //     // 第二个参数就是迭代的初始值(100)，使用100去累加这里的1到10
  //     var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  //    var sac= arr.reduce(function(q,h,i,a){
  // return q+h
  //     },100)
  //     console.log(sac);

  //reduceRight() 方法从数组的最后一项开始，向前遍历到第一项。
  // var result = arr.reduceRight(function(q, h, i, a) {
  //     return q + h;
  // }, 100);
  // console.log(result); //155
  var arr = [3];
  var arr = [4];
  console.log(arr);
</script>
